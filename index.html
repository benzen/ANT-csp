
<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Reveal.js</title>
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">
        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- If the query includes 'print-pdf', use the PDF print sheet -->
        <script>
          document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
        </script>
    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template"># CSP
## Programmation orienté tapis roulants
</script></section><section  data-markdown><script type="text/template">
#Attention
Des scènes violentes pourraient choquer les vieux **nodeJs**.
L'utilisation des jeunes **iojs** et **Coffeescript** est conseillé.
</script></section><section  data-markdown><script type="text/template">
Il était une fois

http://www.infoq.com/presentations/transducer-clojure

(à la minute 42 il dit _channel_)
</script></section><section  data-markdown><script type="text/template">
Il était une autre fois

https://github.com/fxg42/async-comparison
</script></section><section  data-markdown><script type="text/template">
# Callback 
## Hell YEAH

````coffeescript
find: (cb) ->
 Mongo.connect(CONNECTION_STRING, (err, conn) ->
  cb err
  else
    coll = conn.getCollection('person')
    coll.find().toArray (err, data) ->
      if err then cb err
      else cb null, data
````
</script></section><section  data-markdown><script type="text/template">
#async auto 
##_a.k.a._ Make

````coffeescript
getConnection  = (cb)-> ... cb null, connection
getCollection = (cb, {connection})->... cb null, collection
doFind = (cb, {collection})->... cb null, peoples
find: (cb) ->
  async.auto
    connection: getConnection 
    collection: ["connection",getCollection]
    find: ["collection", doFind]
  , (err, {find}) -> cb err, find
````
</script></section><section  data-markdown><script type="text/template">

#csp

````coffeescript
getConnection  = -> ... put chan, connection

find: (cb) ->
  try
    go ->
      connection = yield getConnection()
      collection = connection.getCollection("person")
      collection.find().toArray(cb)
  catch e
    cb e

````
</script></section><section  data-markdown><script type="text/template">
# CSP Begins

![Hoar](images/Sir_Tony_Hoare_IMG_5125.jpg)
</script></section><section  data-markdown><script type="text/template">
# C.A.R. Hoare

* "Classe"
  * Quicksort
  * Go To Statement Considered Harmful
* "Pas Classe"
  * Logique de Hoare (vérification formelle)
  * null
* Channel Sequencial Processing (1978)

</script></section><section  data-markdown><script type="text/template">
# La base

* chan
* put
* take
* go block
</script></section><section  data-markdown><script type="text/template">
Put & take sont bloquants
</script></section><section  data-markdown><script type="text/template">
Rappel générateurs ES6

Javascript
```javascript
var x = function*(){
  yield 'Bonjour'
  yield 'le'
  yield 'monde'
}
var y = x()
y.next() //> Object {value: 'Bonjour, done: false}
y.next() //> Object {value: 'le', done: false}
y.next() //> Object {value: 'monde', done: false}
y.next() //> Object {value: undefined, done: true}
```
Coffeescript
```coffee
 fn = ->
  yield 'Bonjour'
```
</script></section><section  data-markdown><script type="text/template">
Exemple (js-csp)

```coffee
csp = require 'js-csp'
player = (name, table) ->
  csp.go ->
    while true 
      ball = yield csp.take table
      ball.hits++
      console.log name, ball.hits
      yield csp.timeout(100)
      yield csp.put table, ball

table = csp.chan()

player "ping", table
player "pong", table

csp.putAsync table, hits: 0

```
</script></section><section  data-markdown><script type="text/template">
 Le ping pong c'est bien beau
 
 mais moi je fais des vrais systèmes
</script></section><section  data-markdown><script type="text/template">
* pipe (unix |)

```
-> - ->
```


* split 

```
                   |->
->(split(predicat))
                   |->
```
* merge 

```
->|
  (merge) ->
->|
```

* pipline

```
-> (doSomething()) ->
```

* mult

````
   | ->
-> | ->
   | ->
```

* Pub/Sub
* Mix
</script></section><section  data-markdown><script type="text/template">
# &#9829;(Channel) =  Buffer

Fixe

```    
                                  _____
                             ->  |_____| ->

```

Dropping 

```
                                 _______
                           ->    \_____| ->
                                 U 
```  

Sliding

```
                                   ______
                           ->     |______\ ->
                                         U
```
</script></section><section  data-markdown><script type="text/template">
# Exemple plus sensé, mais en go

```go
c := make(chan Result)
go func() { c <- Web(query) } ()
go func() { c <- Image(query) } ()
go func() { c <- Video(query) } ()

timeout := time.After(80 * time.Millisecond)
for i := 0; i < 3; i++ {
    select {
    case result := <-c:
        results = append(results, result)
    case <-timeout:
        fmt.Println("timed out")
        return
    }
}
return
```
</script></section><section  data-markdown><script type="text/template">
# Exemple clojure
## VIVA )

```clojure
(defn append-to-file
  [filename s]
  (spit filename s :append true))

(defn format-quote
  [quote]
  (str "=== BEGIN QUOTE ===\n" quote "=== END QUOTE ===\n\n"))

(defn random-quote
  []
  (format-quote (slurp "http://www.iheartquotes.com/api/v1/random")))

(defn snag-quotes
  [filename num-quotes]
  (let [c (chan)]
    (go (while true (append-to-file filename (<! c))))
    (dotimes [n num-quotes] (go (>! c (random-quote))))))
```
</script></section><section  data-markdown><script type="text/template">
# CSP != Acteur


|                  |  | *CSP*               |  | *Acteur *              |
| ---------------  |  | ------------------- |  | ----------             |
| **On Parle à**   |  | Channel             |  | Processus              |
| **Isolation**    |  | Tous pour un        |  | Chacun pour sois       |
| **Nb processus** |  | *∞ *++              |  | *∞ *++                 |
| **Réseau**       |  | Un jour ...         |  | les doigts dans le nez |

nb: Thread != processus
</script></section><section  data-markdown><script type="text/template">
# Implémentation

* Ada
* Haskell
* Go (Compilateur)
* Clojure core.async (Lib macro)
* cspjs (Marco sweetjs)
* js-csp/node-csp (Genérateur)
</script></section><section  data-markdown><script type="text/template">
JS-CSP: la réponse à tout mes problèmes ?
</script></section><section  data-markdown><script type="text/template">
js-csp n'est pas:

* La réponse à tout tes problèmes
* La seule option (Async.js n'est pas mort, même si ça a 5 ans)
* (encore) **Super** facilement interfacable avec:
  * streams
  * promesses
  * callback
  * event
* décidé sur quoi faire des erreurs
* Multi-tread
* fait pour le réseau
</script></section><section  data-markdown><script type="text/template">
js-csp permet:

* donner un style synchrone a du code  asynchrone
* Simplifier la coordonination de tâches
* de raisoner sur des petits processus simple
</script></section><section  data-markdown><script type="text/template">
#Référence

* David Nolen: http://swannodette.github.io/
* Rick Hickey: http://www.infoq.com/presentations/core-async-clojure
* James Long: http://jlongster.com/Taming-the-Asynchronous-Beast-with-CSP-in-JavaScript
* Rob Pike
  * https://www.youtube.com/watch?v=f6kdp27TYZs
  * http://talks.golang.org/2012/concurrency.slide#1
</script></section></div>
        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } },
              { src: 'plugin/math/math.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default',
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {};
            options = extend(defaultOptions, options, queryOptions);
            Reveal.initialize(options);
        </script>
    </body>
</html>

